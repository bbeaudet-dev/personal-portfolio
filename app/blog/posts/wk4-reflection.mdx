---
collection: "fractal-weekly-reflection"
title: "Abstractions - Week 4 Reflection"
publishedAt: "2025-06-28"
summary: "The infinite nature of data and the applied philosophy of SWE"
---

_Week 4 of Fractal Tech's AI Accelerator & Engineering Bootcamp_

## Can a single sentence capture all of life?

That's the premise of Lucy Ellmann's 2019 novel _Ducks, Newburyport_—a 1,000+ page book written as a single, flowing sentence of over 426,000 words. It spirals through motherhood, memory, mortality, the American Midwest, and the quiet hum of daily life—anchored by the phrase "the fact that," repeated more than 19,000 times. I've only read a few pages of it (for now), but even a short dive is enough to evoke a powerful feeling: that the universe we live in is larger than we can ever imagine, larger than life.

And yet somehow, we manage to live in it anyway. And build things in it. And have barbecues.

A few days before I started Fractal's AI Accelerator, I built a Pokédex app from scratch - just a list of Pokemon on a screen, a text input for registering new Pokemon, and a dropdown for sorting by type. I always considered Pokemon a relatively "simple" game - just Pokémon names, stats, types, some sprites, and a map to walk around. But beneath that? Dozens of data types, deeply nested objects, asynchronous fetch calls, name variants, evolutions, localizations, IDs that differ depending on context, and ALL of that across 9+ generations of differences… It's like trying to recreate a fractal from memory.

### Visible Information

This got me thinking about something Parth keeps telling me: "software engineering is applied philosophy." At first, it might seem like hyperbole that anyone might say about their field, and while there may be some truth to that, I've come to realize just how many fundamental questions we grapple with every day: How do we represent truth in data? What does it mean for something to exist in a system? How should we structure information? What relationships matter? Every architectural decision is really a philosophical stance about how systems work within the world.

This is why I feel more at home in this field. When I think about what I truly want to do—what feels genuinely valuable—it boils down to sharing ideas and making an impact through thought and creativity. Software lets me build with ideas themselves.

Data fascinates me because we've found ways to break up ideas and information into visual, manipulable mediums. We can build real things with that data. There's something compelling about working directly with thoughts and concepts, turning abstract ideas into systems that people actually use.

## The Conversion Rate of Impact

This connects to something I've been thinking about: the "conversion rate" between what I build and what manifests in the world. When I worked on railroad trackwork, my engineering drawings went to manufacturing shops, got built into physical products, shipped to customers, installed into trackwork systems, and eventually carried trains full of New Yorkers. Cool to think about, sure. But my actual contribution? Maybe 0.1% of what passengers experience when riding those trains.

Compare that to when I worked as a pizza cook. I had dough, sauce, and cheese, and I made pizzas that hungry customers enjoyed straight out of the oven. Aside from quality checks and finishing touches, the thing that I made shipped straight to the customer to be enjoyed.

Software engineering sits much closer to the pizza-making end of the spectrum. When I build an app that helps someone organize their thoughts or find information, there are fewer intermediaries between my work and their experience. The computer itself is an intermediary, but it's not like the manufacturing shop, shipping department, installation crew, and transit system that stood between my railroad drawings and actual human impact.

## Abstractions All the Way Down

But here's where software gets beautifully complex: we're dealing with abstraction on top of abstraction on top of abstraction. In mechE and physics, we know pretty well how gravity, friction, and inertia work. We can draw lines and set standards knowing that the next point at which these lines blur and standards fail is in distant galaxies, near black holes, or traveling at light speed—places none of us will ever experience.

In software, the lines we've drawn are much closer to "breakdown points". A new JavaScript framework might make your entire codebase feel obsolete overnight; generative AI is reshaping the entire software engineering landscape as I write this!

Anybody, coding experience or not, is now capable of organizing and presenting information in a new way that breaks our previous conceptions and requires us to draw new boundaries. The limits of our knowledge systems are much more easily broken. And that's both challenging and beautiful.

To move forward in software, we need to metaphorically _break the laws of physics_. We have to grapple with concepts of infinity and granularity, we need to philosophize about systems and scenarios much larger than ourselves, we need to imagine traveling at the speed of light and landing on the surface of the sun (metaphorically, of course). We must build frameworks knowing they'll need to be rebuilt, create order knowing it's temporary.

The truth is, it's turtles all the way down. Infinite complexity in every direction. And that's both impractical—we humans like to design "perfect" systems in an imperfect world—and mind-bogglingly beautiful. Because it means we're part of something bigger than the biggest thing we can imagine, let alone classify into neat little data structures.

Maybe that's why I'm drawn to this work. Not because I can capture all of life in a single sentence or data structure, but because in trying, in building these abstractions and tools and apps, I get to wrestle with infinity every day. I get to be part of humanity's ongoing attempt to make sense of the universe, one API call at a time.

And for me, that's a good enough reason to keep living in it, to keep building.
