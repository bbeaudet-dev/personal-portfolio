---
title: "CLI-only Dice Game"
completedAt: "2025-08-06"
summary: "A terminal/CLI-based dice game combining Balatro's roguelike elements with Farkle's scoring and rules"
technologies: "TypeScript, React, Node.js, Express, Socket.io, Vercel, Render"
githubUrl: "https://github.com/bbeaudet-dev/rollio"
tags: ["Game Dev"]
image: "/images-portfolio/rollio/rollio-cli.jpg"
---

import Image from "next/image";

_A roguelike dice-rolling game experienced exclusively in a Terminal window_

<div className="my-8 w-full max-w-4xl mx-auto">
  <div
    className="relative"
    style={{ paddingBottom: "56.25%", height: 0, overflow: "hidden" }}
  >
    <iframe
      className="absolute top-0 left-0 w-full h-full rounded-lg"
      src="https://www.youtube.com/embed/uoMLUNbIm2c"
      title="Rollio CLI Demo"
      frameBorder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
      allowFullScreen
    ></iframe>
  </div>
</div>

After several iterations of Balatro-inspired dice-rolling games all met the same fate - mixed separation of concerns and disjointed frontend/backend - I had the idea to create a CLI-only game that used extremely minimal UI - and would (hopefully) still be fun.

Theoretically, most games are playable from a command line interface _in some capacity_ - from Tic-Tac-Toe all the way to something like Skyrim! - since it's really the game engine that is directly manipulating the current _GameState_. While your inputs on a controller might be _triggering_ changes to the GameState, it's really the game engine manipulating state behind the scenes, which then prompts updates to the _rendering_ of what you perceive to be the "playable game". For example, you don't really need a visible and clickable 3x3 board to play Tic-Tac-Toe - rather, the 3x3 array making up the board can be represented as a string of text, and players could place markers by inputting two-dimensional coordinates (e.g. "[1,2]") in the CLI instead of clicking on a board.

I wanted to prove that this was possible for my dice-rolling roguelike - and it ended up being a really great exercise for me as a software engineer. By focusing purely on the game engine and CLI interface, I was able to build a solid foundation that could later be extended to other platforms - or so I thought...

After completing the CLI version, I attempted to create a web-based multiplayer version that would run on the same game engine - and while I _was_ successful in creating a working online multiplayer game with live updates, it became quite disjointed from the CLI-version and I ended up scrapping parts of the CLI version so that the web version would work, as well as rewriting a significant amount of game logic within the web components (this is [a problem I have encountered before](/blog/wk6-reflection), and it essentially leads to creating _different_ branching versions of the same game within a single repository - in other words, SLOP!)

<Image
  src="/images-portfolio/rollio/rollio-mpgame.jpg"
  alt="Rollio multiplayer game interface"
  width={800}
  height={600}
  className="rounded-lg my-6"
/>

<Image
  src="/images-portfolio/rollio/rollio-lobby.jpg"
  alt="Rollio game lobby"
  width={800}
  height={600}
  className="rounded-lg my-6"
/>

You can read about [the next stage of this project here](portfolio/rollio-web.mdx), where I picked it up again a few months later and gave the web version another shot.

## Technologies Used

- TypeScript (core logic and type safety)
- React (frontend)
- Node.js & Express (API + server)
- Socket.io (web sockets for real-time multiplayer)
- Vercel (frontend deployment)
- Render (backend deployment)

## Links

- [Github Repository](https://github.com/bbeaudet-dev/rollio)
